1、进程与线程的区别？？
答： 进程就是正在运行的程序,它是线程的集合，线程就是正在运行的程序中的一条执行路径,多线程机会为了提高程序效率

2、多线程的应用场景？？
迅雷多实例下载、短信发送、多线程下载、爬虫采集数据、QQ、分布式job(需要同时一个执行多个任务调度)、使用多线程提高程序的效率、前端开发ajax(异步上传)


3、创建线程有哪些方式？？
答:  1、使用继承Thread类方式,继承Thread类重写run方法
     2、使用实现runnable接口方式
     3、使用匿名内部类方式
     4、 callable
     5、 使用线程池创建线程


4、 什么是同步？什么是异步 ？？？
同步是单线程从上往下执行,按顺序的，异步(多线程)同个时间执行同个代码,多线程之间,每个线程互不影响
Cpu执行权=》主线程先执行再到子线程执行


5、守护线程
Java中有两种线程,一种是用户线程，另一种是守护线程
用户线程是指用户自定义创建的线程,主线程停止,用户线程不会停止
守护线程当进程不存在或主线程停止，守护线程也会被停止
使用setDaemon(true)方法设置为守护线程


什么是守护线程,和main相关

6、多线程运行状态
新建状态 =====》 就绪状态
                  ⬆️
                ⬆️   ⬇️
              ⬆️       ⬇️
          阻塞状态⬅️⬅️⬅️运行状态➡️➡️➡️死亡状态



多线程五个状态讲解：
新建、准备、运行、休眠、停止

新建状态：new Thread();
就绪状态: start()方法 等待cpu调度，就绪状态
运行状态: cpu开始执行run
死亡状态: run方法执行完毕或者stop方法
阻塞状态: 休眠状态,sleep方法或者wait方法,就会使线程睡眠,重新等待cpu调度,就绪状态

join()方法作用
Join作用是让其他线程变为等待;t1.join(); //让其他线程变为等待,直到当前t1线程执行完毕,才释放

Thread.join把指定的加人到当前

Join正在A线程，另一个线程B,A线程调用B的这个join方法，作用:  A等待B线程执行完毕之后(释放我的CPU执行权),在继续执行
优先级。



多线程线程安全（章节）

1、什么是线程安全问题？？？？？
答： 当多个线程同时共享同一个全局变量或静态变量,做写的时候,可能会受到其他线程的干扰，导致数据有问题,这种现象叫做线程安全问题

2、使用同步代码快解决线程安全问题
线程如何实现同步()
多个线程共享同一个全局变量,保证数据安全问题-------保证数据的原子性
解决方法
Synchronized ----- 自动挡
Lock-----jdk1.5并发包-手动
什么地方需要考虑加锁？
考虑 真正产生共享同一全局变量的时候


线程安全问题的解决思路: 当多个不要同时操作同一个全局变量做写的操作


使用synchronized条件：
1、必须要有两个线程以上,需要发生同步
2、多个线程想同步，必须用同一把锁
3、保证只有一个线程进行执行

原理：
 1、有一个线程已经拿到锁,其他线程已经有cpu执行权的,一直排队,等待其他线程释放锁
 2、锁是在什么时候释放？
 代码执行完毕或者是程序跑出异常都会被释放掉
 3、 锁已经被释放掉的话,其他线程开始获取锁进去同步抢锁
 4、锁的资源竞争
 5、死锁的问题
好处:
  解决了多线程的安全问题
 缺点:
  多个线程需要判断锁,较为消耗资源、抢锁的资源,效率非常低


什么是同步函数？
答： 在方法上修饰synchronized成为同步函数
同步函数 使用什么锁？
答: this锁
一个线程使用同步函数,另一个线程是同步代码块this能够同步吗？
答： 可以

一个线程使用同步函数,另一个线程使用同步代码块(非this)不能同步

private Object object = new Object();
同步代码块: synchronized(obj) {}
同步函数(同步方法): public synchronized void  eat()
同步代码块this: synchronized(this) {}

在方法上面，加上synchronized 同步函数
非静态同步函数
同步函数使用this锁
静态(static关键字) 同步函数  this吗？？？
当一变量被static修饰的话存放在永久区，当class文件被加载的时候会被初始化
（字节码文件）作为当前静态的同步函数，
静态同步函数不使用this锁,使用的当前类的字节码文件

两个线程,一个线程使用同步函数，另一个线程使用静态同步函数吗？
不能,同步函数使用this锁,静态同步函数使用当前字节码文件


加锁保证同步，同步是保证数据安全问题 原子问题
分布式锁、高并发和jvm是没有任何关系


如果两个线程之间实现同步，一个线程使用this锁同步代码，
一个线程使用同步函数，如果这两个线程如果同步，
说明了同步函数使用的是this锁

什么是多线程死锁？？
答: 同步中嵌套同步，导致锁无法释放

多线程三大三特性
原子性 独一无二、一致性 保证线程安全问题
可见性 java内存模型
有序性 join，wait、notify(多线程之间通讯)


什么是java内存模型？(属于) 多线程可见性jmm
java内存模型,决定了一个线程与另一个线程是否可见
java内存模型 主内存、(主要存放共享的全局变量) 私有本地内存(本地线程私有变量)
--- 线程安全问题 注意: 本地内存存放主内存中共享数据副本

java内存结构 jvm内存分配


什么是Volatile
Volatile 关键字的作用是变量在多个线程之间可见,但不保证原子性

高并发编程之AtomicInteger讲解
一、AtomicInteger介绍
①.支持原子操作的Integer类
②.主要用于在高并发环境下的高效程序处理。使用非阻塞算法来实现并发控制
博客：高并发编程之AtomicInteger讲解
https://blog.csdn.net/weixin_42146366/article/details/87541488


多线程之间实现通讯
什么是多线程的通讯？
 多个线程对同一个资源(共享资源),每个线程对共享资源做的动作不同,
 操作不同
 多线程通讯的 生产者与消费者 -消息中间件

 wait的作用: 让当前线程从运行状态变为休眠状态,释放锁的资源
 notify： 让当前线程哦那个休眠状态变为运行状态 缓冲

 同步才能使用
 而且要是同一个把锁资源

wait与sleep区别？

对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。
sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。
在调用sleep()方法的过程中，线程不会释放对象锁。
而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备
获取对象锁进入运行状态

synchronized  内置锁  自动化
缺点: 效率低、扩展不高、不能自定义

JDK1.5
并发包Lock锁 保证线程安全问题

于是： lock锁与synchronized同步锁
lock手动挡
手动开始上锁
手动释放锁
灵活性高

Lock lock  = new ReentrantLock();
lock.lock();
try{
//可能会出现线程安全的操作
}finally{
//一定在finally中释放锁
//也不能把获取锁在try中进行，因为有可能在获取锁的时候抛出异常
  lock.unlock();
}




多线程并发(Thread) 操作同一个资源与网站并发 多个请求同时访问一台服务

Lock 接口与 synchronized 关键字的区别？
Lock 接口可以尝试非阻塞地获取锁 当前线程尝试获取锁。如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁。
Lock 接口能被中断地获取锁 与 synchronized 不同，获取到锁的线程能够响应中断，当获取到的锁的线程被中断时，中断异常将会被抛出，同时锁会被释放。
Lock 接口在指定的截止时间之前获取锁，如果截止时间到了依旧无法获取锁，则返回Lock 接口可以尝试非阻塞地获取锁 当前线程尝试获取锁。如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁。 Lock 接口能被中断地获取锁 与 synchronized 不同，获取到锁的线程能够响应中断，当获取到的锁的线程被中断时，中断异常将会被抛出，同时锁会被释放。


Condition用法
 Condition的功能类似于在传统的线程技术中的,Object.wait()和Object.notify()的功能

Condition condition = lock.newCondition();
res. condition.await();  类似wait
res. Condition. Signal() 类似notify

如何停止线程？
停止线程思路
 1.  使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。
 2.  使用stop方法强行终止线程（这个方法不推荐使用，因为stop和suspend、resume一样，
 也可能发生不可预料的结果）。
 3.  使用interrupt方法中断线程。


ThreadLocal
什么是ThreadLocal
ThreadLocal提高一个线程的局部变量，访问某个线程拥有自己局部变量。

 当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。

ThreadLocal的接口方法

ThreadLocal类接口很简单，只有4个方法，我们先来了解一下：

void set(Object value)设置当前线程的线程局部变量的值。
public Object get()该方法返回当前线程所对应的线程局部变量。
public void remove()将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。
protected Object initialValue()返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。v


ThreadLocal的底层原理就是map()集合+当前,set方法底层实现
